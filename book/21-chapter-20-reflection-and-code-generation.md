# Chapter 20: Reflection and Code Generation

PHP uses reflection extensively—dependency injection, ORMs, serialisation. Go has reflection too, but the culture prefers code generation. Understanding both is key to writing idiomatic Go.

## reflect Package Basics

PHP reflection:

```php
$reflectionClass = new ReflectionClass(User::class);
$properties = $reflectionClass->getProperties();
$methods = $reflectionClass->getMethods();
```

Go reflection:

```go
import "reflect"

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func inspectType(v any) {
    t := reflect.TypeOf(v)
    fmt.Println("Type:", t.Name())
    fmt.Println("Kind:", t.Kind())

    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field: %s, Type: %s, Tag: %s\n",
            field.Name, field.Type, field.Tag.Get("json"))
    }
}

inspectType(User{})
// Type: User
// Kind: struct
// Field: Name, Type: string, Tag: name
// Field: Email, Type: string, Tag: email
```

### Type vs Value

```go
t := reflect.TypeOf(user)   // Type information
v := reflect.ValueOf(user)  // Actual value

// Get field value
nameValue := v.FieldByName("Name")
fmt.Println(nameValue.String())

// Set field value (must be addressable)
v := reflect.ValueOf(&user).Elem()
v.FieldByName("Name").SetString("New Name")
```

### Calling Methods via Reflection

```go
method := reflect.ValueOf(user).MethodByName("Greet")
args := []reflect.Value{reflect.ValueOf("World")}
results := method.Call(args)
fmt.Println(results[0].String())
```

## When to Use Reflection (Rarely)

Legitimate uses:

### 1. Serialisation/Deserialisation

```go
// encoding/json uses reflection internally
func marshalStruct(v any) ([]byte, error) {
    val := reflect.ValueOf(v)
    if val.Kind() != reflect.Struct {
        return nil, errors.New("expected struct")
    }

    result := make(map[string]any)
    typ := val.Type()

    for i := 0; i < val.NumField(); i++ {
        field := typ.Field(i)
        jsonTag := field.Tag.Get("json")
        if jsonTag == "-" {
            continue
        }
        name := jsonTag
        if name == "" {
            name = field.Name
        }
        result[name] = val.Field(i).Interface()
    }

    return json.Marshal(result)
}
```

### 2. Generic Utilities

```go
func isNil(v any) bool {
    if v == nil {
        return true
    }
    val := reflect.ValueOf(v)
    switch val.Kind() {
    case reflect.Chan, reflect.Func, reflect.Map,
         reflect.Pointer, reflect.Interface, reflect.Slice:
        return val.IsNil()
    }
    return false
}
```

### 3. Testing Utilities

```go
func assertEqual(t *testing.T, expected, actual any) {
    if !reflect.DeepEqual(expected, actual) {
        t.Errorf("expected %v, got %v", expected, actual)
    }
}
```

### When NOT to Use Reflection

- **Regular type switching**: Use type assertions or generics
- **Performance-critical code**: Reflection is slow
- **When types are known**: Just use the type directly

## Code Generation: `go generate`

Go culture prefers generating code at build time over reflection at runtime.

### The `go generate` Command

```go
//go:generate stringer -type=Status

type Status int

const (
    StatusPending Status = iota
    StatusActive
    StatusCompleted
)
```

Running `go generate ./...` invokes the `stringer` tool, which generates:

```go
// status_string.go (generated)
func (s Status) String() string {
    switch s {
    case StatusPending:
        return "Pending"
    case StatusActive:
        return "Active"
    case StatusCompleted:
        return "Completed"
    }
    return fmt.Sprintf("Status(%d)", s)
}
```

### Writing a Simple Generator

```go
// gen/main.go
package main

import (
    "os"
    "text/template"
)

const tmpl = `
// Code generated by gen/main.go. DO NOT EDIT.
package {{.Package}}

var Endpoints = []string{
{{range .Endpoints}}    "{{.}}",
{{end}}}
`

func main() {
    data := struct {
        Package   string
        Endpoints []string
    }{
        Package:   "api",
        Endpoints: []string{"/users", "/orders", "/products"},
    }

    t := template.Must(template.New("endpoints").Parse(tmpl))
    f, _ := os.Create("endpoints_gen.go")
    defer f.Close()
    t.Execute(f, data)
}
```

Usage:
```go
//go:generate go run ./gen
```

## Build-Time vs Runtime (Unlike PHP's Runtime Reflection)

PHP resolves types at runtime:

```php
// Symfony Container: Resolved at runtime (cached, but still runtime)
$service = $container->get(UserService::class);

// Doctrine: Metadata parsed at runtime
$user = $em->find(User::class, $id);
```

Go prefers build-time resolution:

```go
// Wire: Generates wiring code at build time
//go:generate wire

func InitializeApp() *App {
    wire.Build(NewApp, NewUserService, NewUserRepository, NewDatabase)
    return nil  // Wire replaces this
}
```

Generated `wire_gen.go`:
```go
func InitializeApp() *App {
    database := NewDatabase()
    userRepository := NewUserRepository(database)
    userService := NewUserService(userRepository)
    app := NewApp(userService)
    return app
}
```

### Benefits of Build-Time

1. **No runtime overhead**: Code is just function calls
2. **Compile-time safety**: Errors caught during build
3. **Better debugging**: Generated code is readable
4. **No surprises**: What you see is what runs

## SQLC, Wire, and Other Generators

### SQLC: SQL to Go

```sql
-- queries.sql
-- name: GetUser :one
SELECT * FROM users WHERE id = $1;
```

Generates:
```go
func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
    row := q.db.QueryRowContext(ctx, getUserQuery, id)
    var i User
    err := row.Scan(&i.ID, &i.Name, &i.Email)
    return i, err
}
```

### Wire: Dependency Injection

```go
// wire.go
//go:build wireinject

func InitializeServer() (*Server, error) {
    wire.Build(
        NewServer,
        NewUserHandler,
        NewUserService,
        NewUserRepository,
        NewDatabase,
    )
    return nil, nil
}
```

### mockgen: Interface Mocks

```go
//go:generate mockgen -source=repository.go -destination=mock_repository.go

type UserRepository interface {
    Find(ctx context.Context, id int) (*User, error)
}
```

### Other Popular Generators

- **stringer**: String methods for enums
- **enumer**: Extended enum utilities
- **go-bindata**: Embed binary files
- **protoc-gen-go**: Protocol Buffers
- **oapi-codegen**: OpenAPI to Go

## Summary

- **Reflection** inspects types and values at runtime
- **Use reflection sparingly**—it's slow and bypasses type safety
- **Code generation** creates type-safe code at build time
- **`go generate`** runs generators defined in source comments
- **Popular generators** include SQLC, Wire, mockgen, stringer

---

## Exercises

1. **Struct Inspector**: Write a function that uses reflection to print all fields and tags of any struct.

2. **Generic Validator**: Use reflection to validate struct fields based on tags (e.g., `validate:"required"`).

3. **Simple Generator**: Write a generator that creates getter methods for struct fields.

4. **Wire Setup**: Set up Wire for a simple application with 3-4 dependencies.

5. **SQLC Workflow**: Set up SQLC for a schema. Write queries. Generate code. Use in tests.

6. **Reflection Performance**: Benchmark reflection-based field access versus direct access.

7. **Custom Stringer**: Write a generator that creates `String()` methods with custom formatting.

8. **Generator Testing**: Write tests for a code generator to ensure correct output.
